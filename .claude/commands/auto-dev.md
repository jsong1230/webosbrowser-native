---
description: >
  features.md의 기능을 자동으로 연속 개발합니다.
  기능 완료 후 사용자 개입 없이 다음 기능으로 넘어갑니다.
  독립적인 기능이 여러 개 있으면 자동으로 병렬 배치 개발합니다.
  마일스톤 경계, 문제 발생, 모든 기능 완료 시에만 멈춥니다.
---

## 동작 원칙

**자동 진행**: 기능 완료 → 다음 기능 자동 시작 (사용자 승인 없이)
**멈추는 조건**:
1. 마일스톤 경계 도달 (현재 마일스톤의 모든 기능 완료 시)
2. code-reviewer가 Critical 이슈를 발견하여 해결 불가능할 때
3. 설계 중 사용자 판단이 필요한 중대한 결정 사항이 있을 때
4. 테스트 실패가 자동 수정으로 해결되지 않을 때
5. 모든 기능 완료
6. 의존성 미충족으로 진행 가능한 기능이 없을 때

**자동 판단하는 것들** (멈추지 않고 진행):
- 실행 모드 선택 (순차/병렬): plan.md의 병렬 판단 결과에 따라 자동 결정
- 단일 기능 vs 병렬 배치: features.md의 병렬 그룹(PG-*)에 따라 자동 결정
- 경미한 리뷰 이슈 (Warning, Info): 자동 수정 후 진행
- 테스트 실패 → 수정 → 재테스트 루프: 자동 시도 (최대 2회)

---

## 실행 루프

### Loop Start: 다음 기능(들) 선택
1. docs/project/features.md 읽기
2. "⏳ 대기" 상태 + 의존성 충족(의존 기능이 모두 ✅) 기능 모두 찾기
3. 우선순위(Must > Should > Could) + ID 순서로 정렬
4. **마일스톤 경계 체크**: 현재 마일스톤의 모든 기능이 ✅이면 → 다음 마일스톤 진입 전 사용자에게 보고하고 멈춤
5. 진행 가능한 기능이 없으면 → 사용자에게 보고하고 멈춤
6. 진행 가능 기능을 병렬 그룹(PG-*)별로 분류하고, **그룹 선택 우선순위**에 따라 다음 작업 결정:
   - **그룹 선택 우선순위** (여러 PG-* 또는 단독 기능이 동시에 진행 가능할 때):
     1. 진행 가능 기능 수가 **2개 이상**인 PG-* 그룹을 우선 (병렬 효율)
     2. 같은 조건의 PG-*가 여러 개면 → 그룹 내 최고 우선순위(Must > Should > Could) + 최소 ID 기준
     3. 진행 가능한 PG-* 배치가 없으면 → 단독 기능 중 우선순위 + ID 순서로 1개 선택
   - 선택 결과에 따라 분기:
     - PG-* 배치 (2개 이상) → 병렬 배치 모드 (아래 Step B-1~B-8)
     - 단독 기능 (PG-* 없거나 1개) → 단일 기능 모드 (아래 Step 1~8)

---

## 단일 기능 모드

기존과 동일하게 기능 1개를 순차 파이프라인으로 개발합니다.

### Step 1: 기능 파이프라인 실행
- 기능 상태를 "🔄 진행중"으로 변경
- 기능 설명과 기능명(kebab-case)을 결정
- docs/specs/{기능명}/ 디렉토리 생성

### Step 2: 분석 + 설계 + 계획 (순차)
1. product-manager → requirements.md
2. architect → design.md
   - 사용자 판단이 필요한 중대한 아키텍처 결정(예: 외부 서비스 선택, 비용 발생 결정)이 있으면 → **멈추고 사용자에게 질문**
3. product-manager → plan.md (병렬 실행 판단 포함)

### Step 3: 실행 모드 자동 결정
- plan.md의 "병렬 실행 판단" 섹션 확인
- Agent Team 권장이면 → /fullstack-feature-team 방식으로 실행
- 아니면 → /fullstack-feature 방식으로 실행

### Step 4: 구현 + 기술 문서
- 선택된 모드에 따라 백엔드/프론트엔드 구현
- 각 에이전트가 기술 문서(docs/api/, docs/db/, docs/components/) 작성

### Step 5: 테스트
- test-runner 실행
- 실패 시 → 해당 에이전트로 수정 → 재테스트 (최대 2회 자동 시도)
- 2회 시도 후에도 실패 → **멈추고 사용자에게 보고**

### Step 6: 코드 + 문서 리뷰
- code-reviewer 실행
- Critical 이슈 → 해당 에이전트로 수정 시도 → 재리뷰
  - 수정 불가능한 Critical → **멈추고 사용자에게 보고**
- Warning/Info → 가능한 것은 자동 수정, 나머지는 진행 로그에 기록

### Step 7: 운영 문서 + 커밋
- doc-writer → dev-log.md + CHANGELOG.md
- Git 커밋 (설계문서 / 구현코드 / 기술문서 / 운영문서 분리)

### Step 8: 완료 처리
- features.md 상태 → "✅ 완료"
- 진행 상황 요약 출력 (완료 기능 / 남은 기능 / 현재 마일스톤 진행률)

### → Loop Start로 돌아감

---

## 병렬 배치 모드 (같은 PG-*에 진행 가능 기능 2개 이상)

features.md의 병렬 그룹(PG-*) 컬럼을 읽어 배치를 구성합니다.
분석/설계/계획은 순차로 진행하여 설계 일관성을 유지하고, 구현만 병렬로 수행합니다.

### Step B-1: 배치 구성
- features.md에서 **같은 PG-*에 속한 진행 가능 기능**으로 배치 구성
- PG-*는 project-planner가 기획 시 배정 (같은 마일스톤 + 의존성 없음 + 충돌 영역 미겹침)
- **최대 3개**까지 병렬 (리소스 제한 + 머지 복잡도 고려)
- 3개 초과 시 우선순위 + ID 순서로 상위 3개 선택, 나머지는 다음 루프에서 진행
- 모든 배치 기능 상태 → "🔄 진행중"

### Step B-2: 분석 + 설계 + 계획 (순차)
- 배치 내 각 기능에 대해 **순차적으로** 분석/설계/계획 수행:
  1. product-manager → requirements.md
  2. architect → design.md
  3. product-manager → plan.md
- 기능 A 분석/설계/계획 완료 → 기능 B 분석/설계/계획 → 기능 C ...
- 순차 진행으로 설계 일관성 유지 (기능 간 데이터 모델, API 패턴 등)
- 중대한 결정 필요 시 → **멈추고 사용자에게 질문**

### Step B-3: 기능별 worktree 생성
- 각 기능에 대해 worktree 생성:
```
bash .claude/scripts/worktree-setup.sh {기능명-1} dev
bash .claude/scripts/worktree-setup.sh {기능명-2} dev
bash .claude/scripts/worktree-setup.sh {기능명-3} dev
```
- 결과: `.worktrees/{기능명-1}-dev/`, `.worktrees/{기능명-2}-dev/`, `.worktrees/{기능명-3}-dev/`

### Step B-4: Agent Team → 병렬 구현
- 팀 생성, 기능당 팀원 1명 spawn
- 각 팀원은 자신의 worktree에서 backend + frontend + test 수행
- 참조: 해당 기능의 design.md, plan.md
- 구현 완료 후 기술 문서(docs/api/, docs/db/, docs/components/) 작성

| 팀원 | subagent_type | 작업 디렉토리 | 담당 기능 |
|------|---------------|---------------|-----------|
| {기능명-1}-dev | general-purpose | .worktrees/{기능명-1}-dev/ | 기능 1 전체 |
| {기능명-2}-dev | general-purpose | .worktrees/{기능명-2}-dev/ | 기능 2 전체 |
| {기능명-3}-dev | general-purpose | .worktrees/{기능명-3}-dev/ | 기능 3 전체 |

### Step B-5: 머지
- 각 기능의 worktree를 순차적으로 머지:
```
bash .claude/scripts/worktree-merge.sh {기능명-1} dev
bash .claude/scripts/worktree-merge.sh {기능명-2} dev
bash .claude/scripts/worktree-merge.sh {기능명-3} dev
```
- 충돌 해결 불가 시 → **멈추고 사용자에게 보고**

### Step B-6: 통합 테스트 + 리뷰
- test-runner: 배치 전체에 대해 테스트 실행
- code-reviewer: 배치 전체에 대해 코드 + 설계↔구현 일치 + 문서 리뷰
- Critical 이슈 → 해당 에이전트로 수정 시도 → 재검증
  - 수정 불가능한 Critical → **멈추고 사용자에게 보고**
- 테스트 실패 → 수정 → 재테스트 (최대 2회 자동 시도)
  - 2회 시도 후에도 실패 → **멈추고 사용자에게 보고**

### Step B-7: 운영 문서 + 커밋
- doc-writer → dev-log.md + CHANGELOG.md (배치 내 모든 기능 기록)
- Git 커밋 (설계문서 / 구현코드 / 기술문서 / 운영문서 분리)

### Step B-8: 완료 처리
- 배치 내 모든 기능 상태 → "✅ 완료"
- 진행 상황 요약 출력 (완료 기능 / 남은 기능 / 현재 마일스톤 진행률)

### → Loop Start로 돌아감

---

## 멈췄을 때 출력 형식

```
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
🛑 자동 개발 일시 정지
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

사유: {마일스톤 완료 / Critical 이슈 / 테스트 실패 / 사용자 판단 필요 / 머지 충돌 / 전체 완료}

진행 상황:
- 완료: F-01, F-02, F-03
- 현재: F-04, F-05 (→ 여기서 멈춤 / 완료)
- 남은 기능: F-06, F-07

{사유별 상세 내용}

계속하려면: /auto-dev
```

---

## 시작 시 출력 형식

```
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
🚀 자동 개발 시작
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

features.md 현황:
- ✅ 완료: N개
- ⏳ 대기 (진행 가능): N개
- ⏳ 대기 (의존성 미충족): N개

다음 기능: F-XX {기능명} (외 N개 병렬 가능)
실행 모드: 자동 판단 예정 (단일/병렬 배치)

멈추는 조건: 마일스톤 경계 / Critical 이슈 / 테스트 실패(2회) / 사용자 판단 필요
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
```

---

추가 지시사항: $ARGUMENTS
